#entfernen von f(x) = 
def cleaning_fx():
    Funktion_f = input("Geben sie bitte die vollst√§ndige Funktion an.")
    Funktion_f = list(Funktion_f)
    for w in Funktion_f:
        if w == "=": 
            equal_index = Funktion_f.index("=") + 1
            Funktion_f = Funktion_f[equal_index:] 
        else:
            Funktion_f = Funktion_f
    #rekonstruieren der Funktion
    eq_store = '' # equation-storing
    for w in Funktion_f: 
        eq_store += w #now the equation is rewritten as a string. 
    return eq_store 

def restoring_func(list):

    eq_store = list
    
    # restoring in a list with correct dtype.
    num_store = []
    for w in eq_store: 
        if w == "*": 
            num_store.append(w) 
        elif w == "x": 
            num_store.append("x") 
        elif w == ",": 
            num_store.append(",")
        elif w == "+":
            num_store.append("+")
        elif w == "-":
            num_store.append("-")
        elif w == " ": 
            w = w 
        elif w == 1 or 2 or 3 or 4 or 5 or 6 or 7 or 8 or 9 or 10 or 11 or 12 or 13 or 14: 
            num_store.append(int(w))
        else: 
            print("this is a mistake")
    
    return num_store



def exchange_x(list): 
    x = int(input("Geben sie x ein."))
    num_store = list

    x_index = num_store.index("x")
    num_store.insert(x_index, x)
    num_store.remove("x")

    return num_store


def more_than_2(list):    
    recon_struction_list = []
    count = -1
    count_total = -1
    for a in list: 
        count_total +=1 
    for a in list: 
        count += 1 
        if count != count_total:
            if isinstance(list[count], (float, int)) == True:
                if isinstance(list[count +1], (float, int)) == True:
                    new_num = str(list[count]) + str(list[count +1])
                    new_num = float(new_num)
                    #reconstruction 
                    for a in list[:count]:
                        recon_struction_list.append(a)
                    recon_struction_list.append(new_num)
                    if count+2 < count_total:
                        for a in list[count+2:]:
                            recon_struction_list.append(a)
                else:
                    recon_struction_list.append(a)
            else:
                recon_struction_list.append(a)
                
    return recon_struction_list


def iterations_needed(list):
    counter_iterations = 0
    counter = -1
    count_total = -1
    for a in list: 
        count_total += 1
    for a in list: 
        counter += 1
        if counter != count_total: 
            if isinstance(list[counter], (int, float)):
                if isinstance(list[counter+1], (int, float)):
                    counter_iterations += 1

    return counter_iterations



def more_than_2_complete(list):
    in_range = iterations_needed(list)
    for a in range(in_range): 
        list = more_than_2(list)
    
    return list


def priority(list):
    list  = list
    count_op = 0
    value_op ={'**': 3, "*":2, "/":2, "+":1, "-":1}
    op_priority = {"current_op": 0}
    list_op = []
    for a in list:
        if isinstance(a, (str)) == True:
            list_op.append(a)
    for a in list_op: 
        count_op += 1
        if value_op[a] > op_priority["current_op"]:
            op_priority["current_op"] = value_op[a]   

    return op_priority["current_op"]


def op_selection(list,  op_prioritizer): 
    value_op ={'**': 3, "*":2, "/":2, "+":1, "-":1}
    list = list
    list_count = -1
    for a in list: 
        list_count += 1 #total amount of values in a list. normalized to the index of the values in the list 
    store_value = []  
    store_index_op = []


    index_count = -1
    for a in list:
        index_count += 1 # index of each value in list.
        if isinstance(a,(str)) == True: #these 2 if basically assure that (1) it is an operator/string and (2) that the value mapped to the operator is the op_prioritize/the highest priority operator. 
            if value_op[a] == op_prioritizer: # If this is the case, then one performs the operation with the value indexd before and after it. 
                if a == "+":
                    num_before = list[index_count-1]
                    num_after = list[index_count+1]
                    num_total = num_before + num_after
                    store_value.append(num_total)
                    store_index_op.append(index_count)
            
                elif a == "*":
                    num_before = list[index_count-1]
                    num_after = list[index_count+1]
                    num_total = num_before * num_after
                    store_value.append(num_total)
                    store_index_op.append(index_count)

                elif a == "/":
                    num_before = list[index_count-1]
                    num_after = list[index_count+1]
                    num_total = num_before / num_after
                    store_value.append(num_total)
                    store_index_op.append(index_count)

                elif a == "-":
                    num_before = list[index_count-1]
                    num_after = list[index_count+1]
                    num_total = num_before - num_after
                    store_value.append(num_total)
                    store_index_op.append(index_count)
            
                elif a == "**":
                    num_before = list[index_count-1]
                    num_after = list[index_count+1]
                    num_total = num_before ** num_after
                    store_value.append(num_total)
                    store_index_op.append(index_count)

                else:
                    print("What the fuck is that for an operation?")
    return [list, store_value[0], store_index_op[0], list_count]


def recon_struction(list):

    list_new = list[0]
    num_total = list[1]
    index_count = list[2]
    list_count = list[3]
    list = list_new # doing it so because otherwise it would store the value with index 0 as the new list and so the values would be wrong.


    re_con_list = []


    #recon_before
    for a in list[:index_count-1]: 
        re_con_list.append(a)
    #checks if the the value before it is an equation or if the computed value is part of the equation:
    if list[index_count -2] == "+" or "*" or "-" or "/" or "**":
        re_con_list.append(num_total)
    elif isinstance(list[index_count -2], (int, float)) == True:
        if num_total <= 0:
            re_con_list.append("-")
        elif num_total >= 0:
            re_con_list.append("+")
            re_con_list.append(num_total)
    else:
        print("Here, there is a mistake.")
    #recon_after 
    if index_count +2 < list_count:
    #if 2 values added to the index of the operation is still lower than the list_count. In other words if there comes something after this operation. 
        if list[index_count +2] == "*" or "+" or "-" or "/" or "**":
            for a in list[(index_count + 2):]:
                re_con_list.append(a)
        elif isinstance(list[index_count + 2],(float, int)): 
            re_con_list.append("+")
            for a in list[(index_count + 2):]:
                re_con_list.append(a)

    return re_con_list  


def list_counter(list):
    list = list
    count = 0
    for a in list:
        if isinstance(a, (str)):
            count += 1
        
    return count

def list_counter_total(list):
    list = list
    count = 0
    for a in list: 
        count += 1
    
    return count 

def all():
    list = cleaning_fx()

    list = restoring_func(list)
    print("This is restoring function.")
    print(list)
    print()

    list = exchange_x(list)
    print("This is exachange_x")
    print(list)
    print()

    in_range = list_counter(list)
    for a in range(in_range):
        total = list_counter_total(list)
        if total != 1:
            list = more_than_2(list)
            print("This is more_than_2")
            print(list)
            print()

            list = more_than_2_complete(list)
            print("This is more_than_2_complete")
            print(list)
            print()

            op_prioritizer = priority(list)
            print("This is op_prioritizer")

            list = op_selection(list, op_prioritizer)
            print("This is op_selection")
            print(list)
            print()

            list = recon_struction(list)

    return list[0]
        

a = all()
print(a)
