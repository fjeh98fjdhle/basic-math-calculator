list = [5, 1.0, '*', 'x', '+', 2.0, ['x']]

def exchange_x(list): 
    # in the list that I got from above it is not clear when in the list the variables start. that is the "number", the first value from the list. 
    number = list[0]
    number = number + 1 #number represents the true lenght of the equation. For applying the "stop" in the list a few lines below we need to add by one because the stop doesn't include the given number. 
    #to manipulate the initial list we create an initial list.
    intial_list = list
    #we take out the number that tells us where the variables start and take out the rest of the appended variables so that we only have the pure equation. 
    list = list[1:number]
    list_var = []
    for a in intial_list[number:]:
        a = a 
        for var in a:
            list_var.append(var)
    
    map_var_collection = {} # collects the individual values for all the variables and maps them to the value of the input. 

    #for storing the total function. 
    total_list = []
    part_list = []
    #value mapping.
    char_float = []
    for a in list_var:
        a_value = input("give value for " + a +":")
        name = a 
        for a in char_float: 
            char_float.append(a_value) # creating a list of the values to later reconstruct them.

        # all of this is for the case that a variable is more than just a simple value in which case we would need to reconstruct the number with decimals, not the entire equation because at the end we will cast it to an float. 
        # This entire code will take out the operators that are the closest from both sides so that when I reconstruct and cast the float it everything that comes after the nearest operation and before the nearest operation.
        index_list = []
        index_list_float = []
        close_ness_mapping_before = {}
        close_ness_mapping_after = {}
        index_counter = -1 
        for a in char_float:
            index_counter += 1
            if a == "*":
                index = index_counter
                index_list.append(index)
            if a == "+":
                index = index_counter
                index_list.append(index)
            if a == "-":
                index = index_counter
                index_list.append(index)
            if a == "/":
                index = index_counter
                index_list.append(index)
            if a == ",":
                index = index_counter
                index_list_float.append(index)
            if a == ".":
                index = index_counter
                index_list_float.append(index)

            # have to divide into two different groups were one are the operators before the float number and the ones are after the float number.
        if len(index_list_float) >= 1:
            if len(index_list) >= 1:
                for a in index_list_float:
                    part_list.append(a)
                    for op in index_list:  
                        # op = index for the operation signs in the value of the user input.
                        if a > op:
                            close_ness = a - op # the smaller the difference the more likely one should take it. 
                            close_ness_mapping_before[op] = close_ness
                        elif a < op:
                            close_ness = op - a 
                            close_ness_mapping_after[op] = close_ness
                    part_list.append(close_ness_mapping_before)
                    part_list.append(close_ness_mapping_after)
                    total_list.append(part_list)
                    part_list.clear()
            else: 
                index = index_list_float
        elif len(index_list_float) == 0: 
            if len(index_list) >= 1: 
                 for a in index_list:
        else:
            map_var_collection[name] = int(a_value)

            


    #value in function adding.
    count_index = -1
    for a in list:
        count_index += 1
        for var in list_var:
            if a == var:
                list[count_index] = map_var_collection[a]

    return list

print(exchange_x(list))




                            reverse_mapping_after = {}
                            for a in close_ness_mapping_after: 
                                reverse_mapping_value_after = close_ness_mapping_after[a]
                                reverse_mapping_after[reverse_mapping_value_after] = a 
                                close_ness_mapping_after = []
                            for a in reverse_mapping_after:
                                close_ness_mapping_after.append(a)
                            reverse_mapping_after = sorted(close_ness_mapping_after)
                            reverse_mapping_after = reverse_mapping_after[0]
                            closest_op_after = []
                            closest_op_after = [reverse_mapping_after]
                            for a in closest_op:
                                for b in close_ness_mapping_after:
                                    if a == close_ness_mapping_after[b]:
                                        closest_index_op_back = b



#because I do not have an idea of how to sort on the key values instead of the keys. I will reverse the mapping, for closeness, sort and then reverse back and map them again. 
                            reverse_mapping = {}
                            for a in close_ness_mapping_before: 
                                reverse_mapping_value = close_ness_mapping_before[a]
                                reverse_mapping[reverse_mapping_value] = a 
                                close_ness_mapping = []
                            for a in reverse_mapping:
                                close_ness_mapping.append(a)
                            reverse_mapping = sorted(close_ness_mapping)
                            reverse_mapping = reverse_mapping[0]
                            closest_op = []
                            closest_op = [reverse_mapping]
                            for a in closest_op:
                                for b in close_ness_mapping_before:
                                    if a == close_ness_mapping_before[b]:
                                        closest_index_op = b

                            #reconstruction 
                            for a in close_ness_mapping_before[:closest_index_op + 1]:
                                reconstruction_list.append(a) 
