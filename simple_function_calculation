#entfernen von f(x) = 
def cleaning_fx():
    Funktion_f = input("Geben sie bitte die vollständige Funktion an.")
    Funktion_f = list(Funktion_f)
    for w in Funktion_f:
        if w == "=": 
            equal_index = Funktion_f.index("=") + 1
            Funktion_f = Funktion_f[equal_index:] 
        else:
            Funktion_f = Funktion_f
    #rekonstruieren der Funktion
    num_store = '' # equation-storing
    for w in Funktion_f: 
        num_store += w #now the equation is rewritten as a string. 
    return num_store 

def restoring_func(list):
    list_var = []
    var_index = []
    list = list
    # restoring in a list with correct dtype.
    num_store = []
    index_count = -1
    for w in list: 
        index_count += 1
        if w == "+":
            num_store.append(w)
        elif w == "*": 
            num_store.append(w)
        elif w == "/*": 
            num_store.append(w)
        elif w == "-": 
            num_store.append(w)
        elif w == "1":
            num_store.append(float(w))
        elif w == "2":
            num_store.append(float(w))
        elif w == "3":
            num_store.append(float(w))
        elif w == "4":
            num_store.append(float(w))
        elif w == "5":
            num_store.append(float(w))
        elif w == "6":
            num_store.append(float(w))
        elif w == "7":
            num_store.append(float(w))
        elif w == "8":
            num_store.append(float(w))
        elif w == "9":
            num_store.append(float(w))
        elif w == "0":
            num_store.append(float(w))                                       
        else:
            num_store.append(w)
            list_var.append(w)

    #return the list together with the list of variables, the list of the indexes.
    return_list_and_variables = []
    a = len(num_store)
    return_list_and_variables.append(a)
    for w in num_store: 
        return_list_and_variables.append(w)
    return_list_and_variables.append(list_var)
    
    return return_list_and_variables

def exchange_x(list): 
    # in the list that I got from above it is not clear when in the list the variables start. that is the "number", the first value from the list. 
    number = list[0]
    number = number + 1 #number represents the true lenght of the equation. For applying the "stop" in the list a few lines below we need to add by one because the stop doesn't include the given number. 
    #to manipulate the initial list we create an initial list.
    intial_list = list
    #we take out the number that tells us where the variables start and take out the rest of the appended variables so that we only have the pure equation. 
    list = list[1:number]
    list_var = []
    for a in intial_list[number:]:
        a = a 
        for var in a:
            list_var.append(var)
    
    map_var_collection = {} # collects the individual values for all the variables and maps them to the value of the input. 

    #value mapping.
    for a in list_var:
        a_value = input("Geben sie den Wert für " + a + " an.")
        name = a 
        for a in a_value:  
            a_value = float(a_value)
        map_var_collection[name] = a_value
    
    #value in function adding.
    count_index = -1
    for a in list:
        count_index += 1
        for var in list_var:
            if a == var:
                list[count_index] = map_var_collection[a]

    return list

def more_than_2(list):    
    recon_struction_list = []
    initial_list = list
    count = -1
    count_total = -1
    for a in list: 
        count_total +=1 
    for a in list: 
        count += 1 
        if count != count_total:
            if isinstance(list[count], (float, int)) == True:
                if isinstance(list[count +1], (float, int)) == True:
                    new_num = str(int(list[count])) + str(int(list[count +1]))
                    new_num = float(new_num)
                    #reconstruction 
                    for a in list[:count]:
                        recon_struction_list.append(a)
                    recon_struction_list.append(new_num)
                    if count+2 < count_total:
                        for a in list[count+2:]:
                            recon_struction_list.append(a)
            elif list[count] == "*":
                if list[count +1] == "*":
                    new_op = list[count] + list[count +1]
                    for a in list[:count]:
                        recon_struction_list.append(a)
                    recon_struction_list.append(new_op)
                    if count+2 <= count_total:
                        for a in list[count+2:]:
                            recon_struction_list.append(a)
            elif list[count] == ",":
                if isinstance(list[count +1], (float, int)) == True:
                    num_before = list[count -1]
                    comma = "."
                    num_after = list[count +1]
                    new_num = str(int(num_before)) + comma + str(int(num_after))
                    new_num = float(new_num)
                    for a in list[:count -1]:
                        recon_struction_list.append(a)
                    recon_struction_list.append(new_num)
                    if count+2 <= count_total:
                        for a in list[count+2:]:
                            recon_struction_list.append(a)

        
    list_count = 0     
    for a in recon_struction_list: 
        list_count += 1
    if list_count == 0:
        recon_struction_list = initial_list

    return recon_struction_list

def iterations_needed(list):
    counter_iterations = 0
    counter = -1
    count_total = -1
    for a in list: 
        count_total += 1
    for a in list: 
        counter += 1
        if counter != count_total: 
            if isinstance(list[counter], (int, float)):
                if isinstance(list[counter+1], (int, float)):
                    counter_iterations += 1

    return counter_iterations

def more_than_2_complete(list):
    in_range = iterations_needed(list)
    for a in range(in_range): 
        list = more_than_2(list)
    
    return list

def priority(list):
    list  = list
    count_op = 0
    value_op ={'**': 3, "*":2, "/":2, "+":1, "-":1}
    op_priority = {"current_op": 0}
    list_op = []
    for a in list:
        if isinstance(a, (str)) == True:
            list_op.append(a)
    for a in list_op: 
        count_op += 1
        if value_op[a] > op_priority["current_op"]:
            op_priority["current_op"] = value_op[a]   

    return op_priority["current_op"]

def op_selection(list,  op_prioritizer): 
    value_op ={'**': 3, "*":2, "/":2, "+":1, "-":1}
    list = list
    list_count = -1
    for a in list: 
        list_count += 1 #total amount of values in a list. normalized to the index of the values in the list 
    store_value = []  
    store_index_op = []


    index_count = -1
    for a in list:
        index_count += 1 # index of each value in list.
        if isinstance(a,(str)) == True: #these 2 if basically assure that (1) it is an operator/string and (2) that the value mapped to the operator is the op_prioritize/the highest priority operator. 
            if value_op[a] == op_prioritizer: # If this is the case, then one performs the operation with the value indexd before and after it. 
                if a == "+":
                    num_before = list[index_count-1]
                    num_after = list[index_count+1]
                    num_total = num_before + num_after
                    store_value.append(num_total)
                    store_index_op.append(index_count)
            
                elif a == "*":
                    num_before = list[index_count-1]
                    num_after = list[index_count+1]
                    num_total = num_before * num_after
                    store_value.append(num_total)
                    store_index_op.append(index_count)

                elif a == "/":
                    num_before = list[index_count-1]
                    num_after = list[index_count+1]
                    num_total = num_before / num_after
                    store_value.append(num_total)
                    store_index_op.append(index_count)

                elif a == "-":
                    num_before = list[index_count-1]
                    num_after = list[index_count+1]
                    num_total = num_before - num_after
                    store_value.append(num_total)
                    store_index_op.append(index_count)
            
                elif a == "**":
                    num_before = list[index_count-1]
                    num_after = list[index_count+1]
                    num_total = num_before ** num_after
                    store_value.append(num_total)
                    store_index_op.append(index_count)

                else:
                    print("What the fuck is that for an operation?")
    return [list, store_value[0], store_index_op[0], list_count]

def recon_struction(list):

    list_new = list[0]
    num_total = list[1]
    index_count = list[2]
    list_count = list[3]
    list = list_new # doing it so because otherwise it would store the value with index 0 as the new list and so the values would be wrong.


    re_con_list = []


    #recon_before
    for a in list[:index_count-1]: 
        re_con_list.append(a)
    #checks if the the value before it is an equation or if the computed value is part of the equation:
    if list[index_count -2] == "+" or "*" or "-" or "/" or "**":
        re_con_list.append(num_total)
    elif isinstance(list[index_count -2], (int, float)) == True:
        if num_total <= 0:
            re_con_list.append("-")
        elif num_total >= 0:
            re_con_list.append("+")
            re_con_list.append(num_total)
    else:
        print("Here, there is a mistake.")
    #recon_after 
    if index_count +2 < list_count:
    #if 2 values added to the index of the operation is still lower than the list_count. In other words if there comes something after this operation. 
        if list[index_count +2] == "*" or "+" or "-" or "/" or "**":
            for a in list[(index_count + 2):]:
                re_con_list.append(a)
        elif isinstance(list[index_count + 2],(float, int)): 
            re_con_list.append("+")
            for a in list[(index_count + 2):]:
                re_con_list.append(a)

    return re_con_list  

#for the number of iterations
def list_counter(list):
    list = list
    count = 0
    for a in list:
        if isinstance(a, (str)):
            count += 1
        
    return count

#for the checking how many numbers there are in total.
def list_counter_total(list):
    list = list
    count = 0
    for a in list: 
        count += 1
    
    return count 


def all():
    #list processing
    list = cleaning_fx()
    list = restoring_func(list)
    list = exchange_x(list)
    in_range = list_counter(list)
    for a in range(in_range):
        total = list_counter_total(list)
        if total != 1:
            list = more_than_2(list)
            list = more_than_2_complete(list)
            #actual calculation
            op_prioritizer = priority(list)
            list = op_selection(list, op_prioritizer)
            list = recon_struction(list)

    return list[0]
        

a = all()
print(a)
